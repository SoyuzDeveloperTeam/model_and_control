//---------------------------------------------------------------------------
// ZCNumParser.h
// А. Николенко 01.02.2019
// 
// ZNumericParser
// Описание класса разбора текстовых файлов содержащих Унифицированные
// Формы Обмена. 
// Суть разбора состояит в декомпозиции исходного текста с
// целью выделения подстрок, содержащих только текст, и подстрок, содержащих
// только числовую информацию в виде целого числа. "Числовая" строка может 
// являться частью числа с плавающей или фиксированной точкой.
//
// После разбиения одним из возможных способов (Execute, ProcessString или <<) 
// всего текста на строки и подстроки можно выполнить операцию 
// поиска целых и дробных чисел, а также строковых переменных функциями:
// FindInt, FindDbl, FindStr.
// 
// Класс позволяет организовать программную расшифровку текстового файла
// максимально независимую от используемых в форме разделителей, в том числе 
// и десятичных, пробелов и так далее. Главное чтоб вся информация лежала 
// в нужной последовательности. 
// Например после координаты X следовала координата Y, а далее координата Z
// и так далее...
//---------------------------------------------------------------------------
#ifndef _Z_NUM_PARSER_H
#define _Z_NUM_PARSER_H

//---------------------------------------------------------------------------
// Описание подстроки - составляющей части разбираемой строки или файла
//---------------------------------------------------------------------------
struct ZParserItem {
	string s ;		// Выделенная подстрока текста
	char   type ;	// тип подстроки
					//		0 - пустая строка 
					//		1 - строка символов
					//		2 - число целое
					//		3 - число с фикс. точкой
					//		4 - число с плавающей точкой 
	char   sep ;	//		0 - разделитель отсутствует 	
					//		21- десятичный разделитель '.'
};					//		22- десятичный разделитель ',' 	
					//		31- разделитель ';'
					//		32- разделитель ':'
					//		33- разделитель '/'
					//		34- разделитель '\'	
					// Признаки начала новой строки в массиве строк	
					//		35- разделитель '\r'
					//		36- разделитель '\n' 
					// Признак завершения строки или массива строк
					//		37- разделитель '\0' 
//---------------------------------------------------------------------------
// Вектор (массив) подстрок - результат разбора строки или файла
typedef vector<ZParserItem>				VParserItem ;
typedef vector<ZParserItem>::iterator	IParserItem ;

//---------------------------------------------------------------------------
// Класс для разбора строки или массива строк на составные части
// Каждая такая составная часть содержит либо массив текстовых символов,
// включая пробелы, либо целое число со знаком. Атрибутом составной части
// является разделитель, отделяющий её от последующей составной части строки.
// Составные части фактически являются подстроками
//		Пример разбора	"НУ01:312,23,0,0,3;" ===>
//						===> "НУ01", "312", "23", "0", "0", "3"	
//						"3. -1,3458920e+3"   ===>					 
//						===> "3", "-1", "3458920", "e", "+3"
// Подобным образом можно разобрать УОФ и далее, используя шаблон формы или
// её стандартизованный формат, соответтвующим образом интерпретировать 
// содержащиюся в ней (УОФ) информацию и программно сформировать массив 
// нужной информации.
//---------------------------------------------------------------------------
class FLYCORE_API ZNumericParser {
public:
	ZNumericParser() ;
	virtual ~ZNumericParser() ;

	//-----------------------------------------------------------------------
	// Собственно сам разбор файла или строки 
	//-----------------------------------------------------------------------
	// Полный разбор на подстроки 
	//		файла по указанному маршруту FileName или
	//		уже открытого файла pf, либо текста Text.
	// Приоритет следующий: 1 - FileName, 2 - pf, 3 - Text.
	// Если будут заданы, например, и FileName и Text, то
	// разбор будет выполнен для FileName 
	int Execute(char* FileName, FILE* pf=nullptr, char* Text=nullptr,
				vector<string>* rows=nullptr,
				bool PrintToCout=false) ;

	// Разбор строки на подстроки, содержащие 
	// разделители, символы и целые числа
	int ProcessString(char* S, VParserItem& VPI) ; 
	// Синоним ProcessString для краткого написания кода
	void operator << (char* S) ;

	//-----------------------------------------------------------------------
	// Выделение из подстрок с указанным индексом строк, 
	// чисел целых и дробных.
	// indStr и IndItem указывают на строку и подстроку, 
	// начиная с которой необходимо искать число
	// Возврат 0 - число (строка) наёдено 
	//		   1 - ошибка 
	//		  -1 - числа (строки) не найдено 
	// После возврата IndItem указывает на последную анализируемую
	// подстроку в составе строки indStr
	int FindInt(int indStr, int& IndItem, int& D) ; 
	int FindInt(int indStr, int& IndItem, long& D) ; 
	int FindInt(int indStr, int& IndItem, short& D) ; 
	int FindDbl(int indStr, int& IndItem, float& D) ; 
	int FindDbl(int indStr, int& IndItem, double& D) ; 
	int FindStr(int indStr, int& IndItem, char* S, char* key=nullptr) ; 
	int FindStr(int indStr, int& IndItem, std::string& S, char* key=nullptr);

	// Проверка ключевого слова в указанной позиции
	bool IsText(int indStr, int IndItem, const char* Text) ; 

	//-----------------------------------------------------------------------
	// Какую форму искать
	struct {
		string lf1 = "";
		string lf2 = "";
	} WhatToLookFor;

	//-----------------------------------------------------------------------
	// Разультаты разбора строки на подстроки 
	VParserItem VPI ;

	//-----------------------------------------------------------------------
	// Доступ к результатам разбора
	//-----------------------------------------------------------------------
	// Число найденных строк при разборе
	int GetCountString() { return CountString ; } 
	// Число элементов разбора в строке i.
	// Если i=-1, то общее число найденых элементов разбора
	// В противном случае число элементов разбора с i-й строке 
	int GetCountItems (int i=-1) { 
		if (i<0) return CountItem ; 
		if (i>=CountString) assert(0) ;
		return((i<(CountString-1) ? KeyString[i+1]:CountItem)-KeyString[i]) ;
	} 
	// Положение первого элемента разбора для строки i 
	// в общем массиве массиве элементов разбора VPI
	int KeyForString(int i) { return KeyString[i] ; }

	// Доступ к результатам разборки через перегруженный оператор 
	// скобок как по индексу элемента в общем списке, так по индексам
	// строки и элемента в строке

	ZParserItem& operator () (int i)  { return VPI[i] ; }
	ZParserItem& operator () (long i) { return VPI[i] ; }
	ZParserItem& operator () (short i){ return VPI[i] ; }	
	IParserItem  operator [] (long i) { 
		if (i<0 || i>=CountString) assert(0) ;
		return (VPI.begin()+KeyString[i]) ; 
	}
	IParserItem  operator [] (int   i) { return (*this)[(long)i] ; } 
	IParserItem  operator [] (short i) { return (*this)[(long)i] ; } 

protected:
	// Выделение числа из строки char* S
	// Возвращаемое значение - длинна выделенной подстроки,
	// если возвращается ноль то числа не обнаружено и входная строка
	// содержит просто текст...
	// Результат выделение в элементе "разбора" ZParserItem& PI
	int GetNum (char* S, ZParserItem& PI) ;
	// Выделение текста из строки char* S
	// Возвращаемое значение - длинна выделенной подстроки.
	// Результат выделение в элементе "разбора" ZParserItem& PI
	int GetText(char* S, ZParserItem& PI) ;
	// Проверка на символ-цыфру
	bool IsDigit (char c) ; 
	// Проверки на наличие разделителя
	int  IsSep   (char c) ; 
	int  IsDecSep(char c) ; 
	int  IsStrSep(char c) ; 

private:

public:
	// Буфер для разбора строк
	char SS[256] ;
	// Возможные разделители
	vector<char> DecSeparators ;
	vector<char> StringSeparators ;
	//
	int CountItem ;			// Общее число элементов разбора
	int CountString ;		// число найденных строк
	vector<int> KeyString ;	// положения первых элементов разбора 
							// строк в общем массиве
} ; 

// Оператор разбора строки на подстроки
// Синоним ZNumericParser::ProcessString для краткого написания кода
FLYCORE_API void operator << (VParserItem& VPI, char* S);

//---------------------------------------------------------------------------

#endif // #ifndef _Z_NUM_PARSER_H
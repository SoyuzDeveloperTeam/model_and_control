//-------------------------------------------------------------------------------
// ZMSpaceCraft.h
// А. Николенко 03.08.2018
//------------------------------------------------------------------------------- 
#ifndef ModKA_H
#define ModKA_H
//------------------------------------------------------------------------------- 
#include <FlyMMath.h>
#include <FlyTime.h>

#include <FlyCoreSource\\ModType.h>
#include <FlyCoreSource\\ModGlobal.h>
#include <FlyCoreSource\\ModAstro.h>
#include <FlyCoreSource\\ZMForceGrav.h>
#include <FlyCoreSource\\ModSK.h>
#include <FlyCoreSource\\ModPUManager.h>
#include <FlyCoreSource\\ZCEventManager.h>
#include <FlyCoreSource\\ZCIntegrator.h>
#include <FlyCoreSource\\ZSK.h>
#include <FlyCoreSource\\ZSKNU.h>
#include <FlyCoreSource\\ZPR.h>
#include <FlyCoreSource\\ZNUT.h>
#include <FlyCoreSource\\ZSun.h>
#include <FlyCoreSource\\ZAvrE0.h>

//------------------------------------------------------------------------------- 
//
//------------------------------------------------------------------------------- 
#define COUT_MAIN_EQUATION	8	// Число основных уравнений (время + 6 кинематических параметров + масса)

// Папраметры движения КА на заданный момент времени
// В частности подобная структура формируется после каждого шага интегрирования
// и на время найденного на шаге события
typedef struct ZSC_SI {
	ZMOD_EVENT E ;				// Событие для которого расчитан данный массив параметров движения
								// Например начало витка, очередной шаг, отшагивание назад, минимальная высота и т.д....
	long Vit75 ;				// Витки для АСК 1975, 2000 годов, 
	long Vit00 ;				// текущей и текущей средней эпохи
	long VitTE ;
	long VitTES ;

	// Параметры движени в км, км/сек, рад
	double GSK[6] ;		// Координаты и скорости в ГСК
	double ASKTES[6] ;	// Координаты и скорости в АСК текущей эпохи средней
	double ASKTE[6] ;	// Координаты и скорости в АСК текущей истинной
	double ASK1975[6] ;	// Координаты и скорости в АСК эпихи 1975 года
	double ASK2000[6] ;	// Координаты и скорости в АСК эпохи 2000 года
	double OSK1975[6] ;	// Оскулирующие элементы орбиты относительно экватора эпохи 1975 г.
	double OSKTE[6] ;	// Оскулирующие элементы орбиты относительно экватора текущей истинной эпохи
	double OSKTES[6] ;	// Оскулирующие элементы орбиты относительно экватора текущей средней эпохи
	double OSK2000[6] ;	// Оскулирующие элементы орбиты относительно экватора эпохи 2000 г.
	double THBLFR[9] ;	// 0 - период оск. в секундах, 1 - высота в км, 2 - B, 3 - L, 
						// 4 - fi в градусах, 5 - R в км,
						// 6 - производная от высоты км/сек, 7 - производная от радиуса км/сек.
						// 8 - координата характеризующая смену витка

	bool   isOSK1975bpl ;	// Признаки расчета оскулирующих элементов для альтернативной
	bool   isOSK2000bpl ;	// базовой плоскости и экватора в различных эпохах
	bool   isOSKTEbpl ;
	bool   isOSKTESbpl ;

	double OSK1975bpl[6] ;	// Оскулирующие элементы орбиты для альтернативной 
	double OSKTEbpl[6] ;	// базовой плоскости и экватора в различных эпохах
	double OSKTESbpl[6] ;
	double OSK2000bpl[6] ;

	// Интегрируемые параметры внещних дифференциальных уравнений
	double ExternalEq[EXTEQ_MAXCOUNT] ; // Значения внешних переменных
	int    ExternalEqCount ;// Колличество внешних уравнений
	bool   ExternalEqOn ;	// Признак активности внешних уравнений ("уравнения включены")

	double SA[25] ;			// Характеристики освещённости ("углы Солнцы"). Все углы в радианах

	double   m ;			// Текущая масса КА, кг
	double   tmss ;			// Местное среднее солнечное время, ссс
	double   ta ;			// Время атомное, то самое на которое расчитан данный массив информации
	DATE     Data;			// Дата структурированая (день месяц и год)
	TIME     Time ;			// Время в часах минутах и секундах (московское дикретное)
	TheTimes T ;			// Всё что можно о времени ;
} _ZSC_SI ;

// Параметры движения КА в характерной точке витка, а именно
// в точках максимальной/минимальной высоты или радиуса
typedef struct ZSC_VP {
	bool   isFind ; 
	double tmssvv ;	//
	double R ;		// 
	double H ;		// высота
	double B ;		// Широта
	double L ;		// Долгота
	double t ;		// Время
	double ute ;	// Аргумент широты отсчитанный от экватора текущей эпохи
} _ZSC_VP ;

// Интегральные параметры движения КА на витке
typedef struct ZSC_VI {
	double Td ;		// Период драконический в секундах
	double dL ;		// Межвитковый сдвиг в градусах
	double dLs ;	// Суточное смещение трасы в градусах
	int    Ks ;		// Число суточных витков
	double HAvr ;	// Средняя высота орбиты в км
	double exAvr ;	// Средние компоненты вектора ексцентриситета 
	double eyAvr ;	// e*cos(w)   e*sin(w)
	double ixAvr ;	// Средние компоненты вектора наклонения
	double iyAvr ;	// cos(W)*tg(i/2)   sin(W)*tg(i/2) 

	ZSC_VP UN ;			 // Интегральные параметры в ВУ
	ZSC_VP DN ;			 // .... в НУ
	ZSC_VP Hmax, Hmax2, Hmax3 ; // .... в момент максимальной высоты
	ZSC_VP Hmin, Hmin2, Hmin3 ; // .... в мимент минимальной высоты
	ZSC_VP Rmax, Rmax2, Rmax3 ; // .... в момент максимального радиуса
	ZSC_VP Rmin, Rmin2, Rmin3 ; // .... в момент минимального радиуса
	ZSC_SI FSUN ;// кинематические параметры в ВУ (начале витка)
	ZSC_SI FSDN ;// кинематические параметры в НУ
	ZSC_SI FSTE ;// кинематические параметры в конце витка (в ВУ)
} _ZSC_VI ;

// Выбор глобального минимума или максимумаа на витке из локальных
// минимумов или максимумов высоты или радиуса орбиты
// !!!! В общем случае на витке может быть от 1-го до 3-х локальных
// минимумов или максимумов каждого параметра !!!!
FLYCORE_API ZSC_VP* HMIN_VI(ZSC_VI& I);
FLYCORE_API ZSC_VP* HMAX_VI(ZSC_VI& I);
FLYCORE_API ZSC_VP* RMIN_VI(ZSC_VI& I);
FLYCORE_API ZSC_VP* RMAX_VI(ZSC_VI& I);

//------------------------------------------------------------------------------- 
class ZMAtmSMA81 ;
class ZMAtmSMA62 ;
class ZMAtmSMA440181 ;
class ZCISAManager ;

//-----------------------------------------------------------------------------
// Класс модели движения КА
// "Z" Model of SpaceCraft
//-----------------------------------------------------------------------------
class FLYCORE_API ZMSC : public ZCIntegrator {
public:
	friend class ZModNotice;
	friend class ZCEventManager;
	//-------------------------------------------------------------------------
	// Диспетчер программ управления 
	// Позволяет управлять формированием моделируемых программ управления 
	// движением центра масс КА, а так же инкапсулирует расчёт 
	// реактивных ускорений обусловленных работой той или 
	// иной двигательной установки КА
	//-------------------------------------------------------------------------
	ZPUManager MPU;

	//-------------------------------------------------------------------------
	// Менеджер событий модели движения
	// Инкапсулирует метод уточнения момента в пределах шага 
	// интегрирования того или иного актуального события.
	// Актуальными событиями являются события макc/мин высоты и радиуса 
	// в случае моделирования посредством функции GoAlongVit, а так же 
	// события ЗРВ в случае поиска ЗРВ и расчёта их характеристик 
	// (был вызван метод RunUpZRV) . 
	//-------------------------------------------------------------------------
	ZCEventManager EventMng;

protected:
	ZKA    KA;				// Данные о КА 
	ZNU	   NU;				// Исходные НУ
	ZLSF   LSF;				// Логическая шкала сил
	int	   HStoryClarify;	// Ключ для сохранения и восстановления 
	// состояния Модели движения в пределах 
	// вычислительных процедур уточнения требуемых 
	// значений параметров движения. Например: 
	// уточнение момента ВУз или НУз, моментов 
	// максимальной или минимальной высоты...
	long   Vitok75;			// Виток в АСК 1975
	double TestVit75Z0;

private:
	//
	ZModNotice*	    m_pNotice;
	// Диспетчер индексов солнечной активности
	ZCISAManager*   m_ISAManager;
	// Объект моделирующий атмосферу статическую 81 года
	ZMAtmSMA81*     m_AtmSMA81;
	// Объект моделирующий атмосферу статическую 62 года
	ZMAtmSMA62*     m_AtmSMA62;
	//
	ZMAtmSMA440181* m_AtmSMA440181;
	// Гравитационное поле земли
	ZMForceGrav	    GPZ;

	// Текущие параметры движения (то есть для текущего шага)
	// Поля для хранения расчётных параметров движения в разных СК
public:
	ZSC_SI FSC;	// для текущего шага (последнего)
	ZSC_SI FSP;	// для предыдущего шага (предпоследнего)
	ZSC_SI FSR;	// для результатов прогноза - выход на виток, 
	// на аргумент или на время
	// !!!! Очень важное поле! Тут находятся результаты 
	// прогнозирования получаемые посредством ф-ий:
	// GoAlongVit, GoToVit, GoToVitU, GoToU, GoToDU
	// GoToTime, GoDTime. !!!! 
	ZSC_SI FSE;	// для последнего уточнённого события в пределах 
	// сделанного шага (от FSP.ta до FSC.ta)
	ZSC_VI FV;	// Поле для хранения параметров витка при прогнозировании 
	// движения по виткам. Заполняется процедурой 
	// моделирования движения КА вдоль 
	// заданного витка GoAlongVit.

public :
	ZMSC ( ) ;
	~ZMSC( ) ;

	//-------------------------------------------------------------------------
	// Инициализация модели
	//		Nu		- начальные условия.
	//		NuKey	- ключи начальных условий.
	//		lsf_	- логическая шкала сил в которой будет выполняться 
	//				  моделирование.
	//		EED		- описание состава внешних переменных.
	int Init(ZNU& Nu, ZLSF* lsf_=nullptr, 
			 ZCExternalEquationsDefinition* EED=nullptr) ;
	int Init(ZKEYNU& NuKey, 
			 ZCExternalEquationsDefinition* EED=nullptr) ;

	// Структура для переопределения некоторых параметров и характеристик
	// модели движения имеющих смысл при её инициализации. Значения ниже 
	// следующих полей структуры аткуальны только перед вызовом метода
	// Init. После вызова данного метода значения полей структуры 
	// ни на что не влияют
	struct {
		// Заданный фиксированный шаг интегрирования СДУ. 
		// Если значение данного поля больше нуля, то оно воспринимается 
		// как фиксированный шаг интегрирования СДУ в секундах. 
		// Если defautFixedStep>0, то интегратор шаг не выбирает автоматически 
		// (не увеличивает и не уменьшает), вместо этого интегрирует 
		// с постоянным шагом defautFixedStep.
		double defautFixedStep;
	} PreInitInfo;

	//-------------------------------------------------------------------------
	int GetNumKA() const { return KA.num ; } ;
	int GetNumNU() const { return NU.Key.nom; };
	ZKEYNU GetKeyNU() const { return NU.Key; };
	// Получение текущих ИД и параметров движения
	void   GetLSF(ZLSF& lsf) const;
	void   GetKA(ZKA& ka) const;
	void   GetNU(ZNU& nu) const;
	int    SetNU(ZNU& nu);
	double GetTime() const;
	long   GetVitok(SK_TYPE sk=_SK_ASKTE, ZSC_SI* F=nullptr) const;
	double GetU    (SK_TYPE sk=_SK_ASKTE, ZSC_SI* F=nullptr, 
					bool isbpl=false) const;
	int    GetVector(double* X, long* Vit=nullptr, double* t=nullptr, 
					double* m=nullptr, SK_TYPE sk=_SK_ASK1975) const;
	// Задать значения текушего вектора состояния КА
	int    SetVector(double* X, long Vit, double t, double m, 
					SK_TYPE sk=_SK_ASK1975) ;
	// Начальный вес КА (сухой и с топливом)
	double WeightNU() const;
	double WeightFullNU() const;
	// Текущий вес КА с топливом
	double WeightFull() const;
	// Текущий вес топлива
	double WeightFuel() const;

	//-------------------------------------------------------------------------
	// ПРОГНОЗИРОВАНИЕ ПО ВРЕМЕНИ
	// Прогноз на заданный момент времени
	virtual int GoToTime(double  t, ZSC_SI* SI=nullptr) ;
	// Прогноз на заданный интервал от текущего момента времени
	virtual int GoDTime (double dt, ZSC_SI* SI=nullptr);
	// Один шаг интегрирования с автоматическим выбором
	// Если задана величина notFurtherTime, то шаг будет выполнен таким образом
	// что полученное временя будет меньше либо равно notFurtherTime
	// Целесообразно использовать при реализации программного пошагового выхода 
	// на заданный момент времени - альтернатива функции GoToTime() 
	virtual int GoStepA (ZSC_SI* SI=nullptr, int dir=1, 
					double* notFurtherTime=nullptr, 
					ModEventName* BreakKey=nullptr) ;

	//-------------------------------------------------------------------------
	// ПРОГНОЗИРОВАНИЕ ПО АРГУМЕНТУ ШИРОТЫ И ПО ВИТКАМ
	// Прогноз движения на витке с формированием результатов на конец витка
	// и расчётом интегральных характеристик витка
	virtual int GoAlongVit(long vit, SK_TYPE sk=_SK_ASKTE) ; 
	// Прогноз до заданного витка 
	// (восходящий или нисходящий узел) в заданной эпохе
	virtual int GoToVit (long  vit, ZSC_SI* SI = nullptr, bool fronNUZ = false, 
					SK_TYPE sk = _SK_ASKTE);
	// Прогноз до заданного витка и агрумента широты (град) в заданной эпохе
	virtual int GoToVitU(long  vit, double u, ZSC_SI* SI = nullptr, 
					SK_TYPE sk = _SK_ASKTE);
	// Прогноз до заданного аргумента широты (град) в заданной эпохе на 
	// текущем витке
	virtual int GoToU(double  u, ZSC_SI* SI = nullptr, 
					SK_TYPE sk = _SK_ASKTE);
	// Прогноз на заданное угловое расстояние (град) вдоль орбиты от текущего положения
	virtual int GoToDU(double du, ZSC_SI* SI = nullptr);

	//-------------------------------------------------------------------------
	// РЕАЛИЗАЦИЯ МЕХАНИЗМА ВЕРТИКАЛЬНОГО РАСШИРЕНИЯ ИНТЕГРИРУЕМОЙ СИСТЕМЫ
	// ДИФФЕРЕНЦИАЛЬНЫХ УРАВНЕНИЙ - подключение к основным уравнениям движения
	// дополнительных (внешних) уравнений - увеличение размерности задачи Коши
	// 	
	// Внешние переменные описываются параметром 
	// ZExternalEquationsDefinition* EED
	// при вызове метода инициализации модели движения Init. Таким образом 
	// состав внешних уравнений определяется только в момент создания модели 
	// движения и в дальнейшем "на лету" изменён быть не может. Для изменения 
	// состава внешних уравнений придётся пересоздать объект модели движения.
	// !!!! В дальнеёшем этот недостаток планируется устранить !!!!
	//-------------------------------------------------------------------------
	// Включить интегрирование внешних уравнений
	//		NU - начальные условия для внешних переменных 
	virtual void ExternalEquationsOn (double* NU=nullptr) ;
	// Выключить интегрирование внешних уравнений
	//		X  - значения внешних переменных в момент отключения 
	//			 внешних уравнений 
	virtual void ExternalEquationsOff(double* X=nullptr) ;
	// Виртуальная функция для реализации расчёта правых частей 
	// внешних уравнений
	//		t	  - время,
	//		mainX - основной вектор (кинематические параметры и масса КА),
	//		Xexe  - внешние переменные,
	//		Yexe  - производные внешних уравнений.
	virtual int  ExternalSph(double t, double* mainX, double* Xexe, 
					double* Yexe) ; 

	//-------------------------------------------------------------------------
	// Сохранение и восстановление состояния модели движения
	// Под состоянием модели движения понимается совокупность следующих данных:
	//		- текущий момент времени ZModIntegrator::m_a[0], 
	//		- вектор кинематических параметров в СК интегрирования СДУ 
	//		  (АСК-1975) ZModIntegrator::m_a[1, 2, 3, 4, 5, 6],
	//		- текущий виток в СК интегрирования Vitok75, 
	//		- расчётные параметры шага FSC, 
	//		- расчётные параметры предыдущего шага FSP, 
	//		- расчётные параметры последнего найденного события FSE, 
	//		- расчётные параметры витка FV
	//-------------------------------------------------------------------------
	virtual int  Story    (int  HStory=0) ; 
	virtual int  ReStory  (int  HStory ) ; 
	virtual void FreeStory(int* HStory=nullptr) ; 

	// Доступ к расчётным характеристикам витка (при моделировании движения 
	// по виткам) MKA_VI* GetFV() { return &FV ; }
	// Доступ к расчётным параметрам движения в текущий момент времени 
	// (при моделировании движения по времени)
	// Функция возвращает расчётные параметры либо на момент последнего шага,
	//ZSC_SI* GetFS() { return (FSE.E.ID>0 ? &FSE:&FSC) ; }
	// Функция возвращает расчётные параметры движения на момент 
	// предыдущего шага шага,
	//ZSC_SI* GetFSP() { return &FSP ; }

	//-------------------------------------------------------------------------
	// Методы для рассчёта ЗРВ, точнее отслеживания на лету, то есть 
	// одновременно с обычным прогнозом параметров движения, событий 
	// ЗРВ (вход, выход, параметр) 
	//-------------------------------------------------------------------------
	// Инициализация начала отслеживания ЗРВ
	int RunUpZRV(int CountNip, int* NipIndexes ) ;
	// Завершение отслеживания ЗРВ
	void CompletZRV() ;

	//-------------------------------------------------------------------------
	// Методы отслеживания событий витка
	// Инициализация начала отслеживания событий витка
	int RunUpVit() ;
	// Завершение отслеживания событий витка
	void CompletVit() ;

protected :
	// Один шаг интегрирования - шаг назад (используется для уточнения 
	// обнаруженного события)
	virtual int BackStep(ZSC_SI* SI, double h, 
						 ModEventName idevent=ModEvent_EMPTY) ;
	// Переразгон от события при разрыве ПЧ СДУ (в случае если заданы новые НУ, 
	// добавлены внешние уравнения или дополнительные возмущающие факторы)
	int RestartFromEvent() ; 
	int CheckVitEvent(ZSC_SI* SI=nullptr, bool fronNUZ=false, SK_TYPE sk=_SK_ASKTE) ;  

	void Clear( ) ;
	// Пошаговая функция
	virtual int StepBreak(double t, double* X) ;
	// Обработка событий модели
	virtual int OnMessage   (long ModMsgID, double* t, double* X) ;
	virtual int OnEvent     (ZMOD_EVENT& E, ZSC_SI* PSE) ;
	virtual int OnVitokEvent(ZMOD_EVENT& E, ZSC_SI* PSE) ;
	virtual int OnUserEvent (ZMOD_EVENT& E, ZSC_SI* PSE) ;
	virtual int OnZRVEvent  (ZMOD_EVENT& E, ZSC_SI* FSC) ;
	virtual int OnFullZRV   (ZZRV* ZRV, ZSC_SI* FSC) ;

	virtual int Sph(double* X, double* Y) ;
	virtual int StepCalc(char ForTheCase=1, ModEventName idevent=ModEvent_EMPTY, 
						 ZSC_SI* SI=nullptr) ;
	virtual int CalcAstroKoord(double t, int NP) ; 

	long   VitSK	 (double* Ask1, long V1, double* Ask2) ; 
	int    ClarifyVit(ZSC_SI* SI, double tp, double Zp, double tt, double Zt, 
					  bool fronNUZ=false, SK_TYPE sk=_SK_ASKTE) ;

	// Быстрое сохранение (до уточнения события) 
	// и быстрое восстановление (после уточнения события) состояния интегратора
	// !!!! Именно интегратора а не всей модели движения !!!!
	void   FastStory  () ; 
	void   FastReStory() ; 
	double FastX[EXTEQ_MAXCOUNT+COUT_MAIN_EQUATION] ;
	double FastGI[2][EXTEQ_MAXCOUNT+COUT_MAIN_EQUATION] ;

	void ASKtoASKbpl(double* X, double* Xbpl) ;

private :
	void   PreTestVit () ;
	void   TestVit    () ;
	double KoordVit   (double* X=nullptr) ;
	double KoordVVit  (double* X=nullptr) ;
	double KoordVitSK (ZSC_SI* SI=nullptr, SK_TYPE sk=_SK_ASKTE) ;
	double KoordVVitSK(ZSC_SI* SI=nullptr, SK_TYPE sk=_SK_ASKTE) ;
	int    TestEpsVit (SK_TYPE sk1, double* Ask1, long Vit1, 
					   SK_TYPE sk2, double* Ask2, long& Vit2) ; 

	// Функции FillStep... вызываются моделью после каждого шага для
	// расчёта всех возможных параметров движения и записи их значений 
	// в структуру ZSC_SI* SI.

	// Формирование кинематических параметров движения в АСК-1975 года 
	// и оскулирующих элементов в этой эпохе
	int FillStepInfo75 (ZSC_SI* SI, int var) ;  
	// Формирование кинематических параметров движения в АСК-2000 года
	// и оскулирующих элементов в этой эпохе
	int FillStepInfo00 (ZSC_SI* SI, int var) ;  
	// Формирование кинематических параметров движения оскулирующих
	// элементов в АСК текущей эпохи
	int FillStepInfoTE (ZSC_SI* SI, int var) ;  
	// Формирование кинематических параметров движения оскулирующих
	// элементов в АСК текущей средней эпохи
	int FillStepInfoTES(ZSC_SI* SI, int var) ;  
	// Формирование кинематических параметров движения в ГСК
	int FillStepInfoGSK(ZSC_SI* SI) ;  
	// Расчёт оскулирующего периода, высоты, геодезических широты и долготы
	int FillStepInfoTHBL(ZSC_SI* SI) ;  
} ;

//-----------------------------------------------------------------------------
// !!!! Объекты класса ZMSC при их сождании в стеке занимают достаточно много 
// места и как следствие не помещаются в обычный размер стека. Поэтому
// целесообразно создавать данные объекты в куче. Но! тогда в программном коде
// необходимо следить за удалением подобных объектов из памяти. Что не очень 
// удобно и загромождает программный код. Ситуацию могут исправить
// смарт-указатели, или некоторое их подобие ... Например
// шаблон ZTSelfRemovPointer, который оборачивает указатель на создаваемый 
// объект, сам объект создаётся автоматически при создании экземпляра
// ZTSelfRemovPointer и так же автоматически удаляется при удалении 
// ZTSelfRemovPointer, например при выходе за пределы видимости программного
// кода в котором создан ZTSelfRemovPointer
//-----------------------------------------------------------------------------
#define PZMSC ZTSelfRemovPointer<ZMSC>

//-----------------------------------------------------------------------------
// Пример
// В программном коде можно написать  
//  1)
//		ZMSC KA;
//		KA.GoTo...
//		. . . .
//		Но это не разумно с точки зрения задествования стека
//  2)
//		ZMSC* KA;
//		KA.GoTo...
//		. . . .
//		delete KA;
//		В таком случае возможно в теле процедуры придётся
//		многократно вызывать delete KA если вычислительный процесс 
//		имеет много выходов
//	3)
//		PZMSC KA;
//		KA->GoTo...
//		. . . .
//		В таком случае явно удалять модель движения из памяти не нужно
//		и размеры стека увеличивать не нужно.
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
// Макросы определяющие классы, наследуемые от ZModKA с целью "горизонтального"
// и (или) вертикального расширения системы дифференциальных уравнений.
// 
// "Вертикальное" расширение	- добавление новых уравнений в систему
// "Горизонтальное" расширение	- добавление новых слогаемых в правые части
//								  дифференциальных уравнений системы
// Пример
// ZMSCvex(ZModAvr)	-	объявление класса ZModAvr позволяющего расширить состав
//						интегрируемых дифференциальных уравнений
// Для реализации класса необходимо реализовать виртуальную функцию 
// int ZModAvr::ExternalSph(double t, double* Xmain, double* Xexe, double* Yexe) 
// где:		t		-	текущее время,	 
//			Xmain	-	вектор основных параметров движения 
//							(X,Y,Z, Vx,Vy,Vz, m),	 
//			Xexe	-	вектор дополнительных координат, его размерность равна 
//						колличиству дополнительных уравнений и устанавливается
//						методом модели движения 
//							SetExternalEquationsCount(int)
//						до момента инициализации модели (то есть до вызова метода
//							Init)
//			Yexe	-	вектор производных дополнительных координат как функций 
//						времени	
//							Yexe[i] = d(Xexe[i])/d(t).
//
// Интегрирование дополнительных переменных можно "включить" и "выключить" 
// в режиме RunTime. Приостановка (отключение) интегрирования осуществлюяется 
// при помощи метода
//							ExternalEquationsOff(double* X=nullptr) 
// где в переменной X можно при необходимости получить текущие значения 
// дополнительных переменных.
// Возобновление интегрирования дополнительных переменных выполняется 
// посредством вызова метода 
//							ExternalEquationsOn (double* NU=nullptr) 
// где в переменной NU можно задать новые начальные значения дополнительных 
// переменных, если начальные значения не задаывать то в качестве таковых 
// модель движения будет использовать последние поученные рассчётные значения.
// 
// При инициализации модели движения в качестве начальных значений 
// дополнительных переменных принимаются нулевые значения.
// 
// Получить значение дополнительных переменных в любой момент времени можно, 
// вызвав метод интегратора ZIntegrator 
//							void  GetVectorExe(double*)
// Задать значения можно при помощи функции
//							int   SetVectorExe(double*) 
// Конечно же при принудительном задании значений дополнительных переменных
// будет иметь место разрым правых частей СДУ и как следствие "переразгон"
// численного алгоритма интегрирования СДУ со всеми вытекающими из этого 
// последствиями...
//
//-----------------------------------------------------------------------------
// Примеры синтаксиса 
// 
// Класс ZModelExVar наследуемый от ZMSC для интегрирования 
// N дополнительных уравнений
//
// Объявление класса и одновременная реализация метода расчёта правых частей
// дополнитедбных дифференциальных уравнений 
//
//			ZMSC_EXV_BEG(ZModelExVar)
//				// Правые части внешних дифференциальных уравнений
//				// Входные параметры:  t, Xmain, Xexe.
//				// Результаты расчёта: Yexe. 
//				.............
//				Yexe[0] = ... ;
//				Yexe[1] = ... ;
//				.............
//				Yexe[N] = ... ;
//				.............
//			ZMSC_END
//
// Класс ZModelExForce наследуемый от ZMSC для расширения состава возмущающих 
// факторов которые необходимо учитывать при моделировании движения КА
//
// Объявление класса и одновременная реализация метода расчёта правых частей
// дополнитедбных дифференциальных уравнений 
//
//			ZMSC_EXH_BEG(ZModelExForce)
//				// Правые части дифференциальных уравнений
//				// Входные параметры:  t, X, N, Y.
//				// Результаты расчёта: Y. 
//				// N - число уравнений, очевидно равно 7(это X,Y,Z,Vx,Vy,Vz,m)+ 
//				//     + колличество внешних уравнений 
//				// На входе в функцию Y содержит производные параметров 
//				// движения (в том числе и дополнительных) по времени, 
//				// рассчитанные в соответствии с моделью движения КА ZMSC и
//				// методом ExternalSph. 
//				// Данные производные могут быть дополнены новыми слогаемыми.
//				..........
//				Y[0]+= ... ;
//				Y[1]+= ... ;
//				Y[2]+= ... ;
//				..........
//				Y[7]+= ... ;
//				..........
//			ZMSC_END
//
// Класс ZModelEx, реализующий как вертикальное так и горизонтальное расширение
// Объявление класса и одновременная реализация методов
//
//			ZMSC_EXHV_BEG(ZModelEx)
//				// Реализация дополнительных дифференциальных уравнений
//				.............
//				Yexe[0] = ... ;
//				Yexe[1] = ... ;
//				.............
//				Yexe[N] = ... ;
//				.............
//			ZMSC_EXTFORCE(ZModelEx)
//				// Реализация дополнительных возмущающих факторов
//				..........
//				Y[0]+= ... ;
//				Y[1]+= ... ;
//				Y[2]+= ... ;
//				..........
//				Y[7]+= ... ;
//				.......... ;
//				Y[N]+= ... ;
//				..........
//			ZMSC_END
//
//-----------------------------------------------------------------------------
// Можно написать код более традиционным образом.
// В файле заголовка: 
//
//			ZMSC_EXHV_DEF(ZModelEx)
//
// В файле реализации класса:
//
//			int ZModelEx::ExternalSph(double t, double* Xmain, 
//									  double* Xexe, double* Yexe)
//			{ 
//			...........	
//
//			...........
//			return 0 ;
//			}
//
//			int ZModelEx::ExternalForces(double t, double* X,  
//										 double* Y, int N)
//			{ 
//			...........	
//
//			...........
//			return 0 ;
//			}
//
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
// Горизонтальное расширение
#define ZMSC_EXH_DEF(ClassName)\
class ClassName : public ZMSC {\
public:\
	ClassName() {} ;\
	~ClassName(){} ;\
	virtual int ExternalForces(double t, double* X, double* Y, int N) ;\
} ;

#define ZMSC_EXH_BEG(ClassName)\
ZMSC_EXH_DEF(ClassName)\
int ClassName::ExternalForces(double t, double* X, double* Y, int N) ;\
{

//-----------------------------------------------------------------------------
// Вертикальное расширение
#define ZMSC_EXV_DEF(ClassName)\
class ClassName : public ZMSC {\
public:\
	ClassName() {};\
	~ClassName(){};\
	virtual int ExternalSph(double t, double* Xmain, double* Xexe, double* Yexe);\
} ;

#define ZMSC_EXV_BEG(ClassName)\
ZMSC_EXV_DEF(ClassName)\
int ClassName::ExternalSph(double t, double* Xmain, double* Xexe, double* Yexe)\
{

//-----------------------------------------------------------------------------
// Одновременное горизонтальное и вертикальное расширение
#define ZMSC_EXHV_DEF(ClassName)\
class ClassName : public ZMSC {\
public:\
	ClassName() {} ;\
	~ClassName(){} ;\
	virtual int ExternalSph(double t, double* Xmain, double* Xexe, double* Yexe);\
	virtual int ExternalForces(double t, double* X, double* Y, int N);\
} ;

#define ZMSC_EXHV_BEG(ClassName)\
ZMSC_EXHV_DEF(ClassName)\
int ClassName::ExternalSph(double t, double* Xmain, double* Xexe, double* Yexe)\
{

#define ZMSC_EXTFORCE(ClassName)\
	return 0 ;\
}\
int ClassName::ExternalForces(double t, double* X, double* Y, int N)\
{

//-----------------------------------------------------------------------------
// Завершение макросов ZMSC_EXH_BEG  ZMSC_EXV_BEG  ZMSC_EXHV_BEG 
#define ZMSC_END\
	return 0 ;\
}

//-----------------------------------------------------------------------------
#endif // #ifndef ModKA_H

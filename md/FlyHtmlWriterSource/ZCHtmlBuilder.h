//-----------------------------------------------------------------------------
// ZCHtmlBuilder.h
//
// Класс-писатель HTML-документа. Класс предназначен для обьлегчения операции
// документирования результатов вычислений в формате HTML. 
// Пример использования.
//		1) Создание экземпляра "писателя"
//				ZCHtmlBuilder H;
//
//		2) Контент документа состоит из отдельных элементов ZСHtmlItem.
//
//		3) Каждый такой элемент добавляется в стуртуру документа простым 
//		   оператором
//				ZСHtmlItem I;
//				H << I;
//		   либо 
//				H << ZСHtmlItem(...);
//		   Каждый элемент HtmlItem является контейнером элементарной 
//		   конструкции HTML и содержит:
//				- имя тега, например "p" (в документе появится <p>),
//				  "div", "span", "table",...
//				- атрибуты тега (например: color=#FF00FF)
//				- текст заключаемый в этот тег
//				- список дочерних тегов (дочерних, вложенных HtmlItem)
//				- положение текста относительно дочерних тегов, если
//				  задано значение 0, то текст отображается перед всеми
//				  дочерними тегами, если 2, то текст отображается в документе
//				  между вторым и третьим дочерними тегами
//		   Все составляющие части HtmlItem могут быть заданы в его 
//		   конструкторе за исключение списка дочерних тегов.
//
//		4) Доступ к отдельным элементам документа определён посредством
//		   перегруженного оператора ():
//				H(0) ... H(1) ... H(12) ...
//		   Оператор возвращает ссылкак на ZСHtmlItem, поэтому через ()		
//		   возможен доступ к полям класса ZСHtmlItem:
//				H(0).n		- имя тега;
//				H(0).txt	- текст заключённый в тег;
//				H(0).txtPos	- положение текста среди дочерних тегов.
//		   Досткуп к списку атрибутов осуществляется посредством 
//		   перегруженного оператора []
//				H(0)[0]		- первый атрибут тега
//				H(0)[1]		- второй атрибут тега
//		   О содержании каждого атрибута и способах его внедрения 
//		   в структуру объекта HtmlItem будет сказано ниже в пункте 8. 
//
//		5) Если в тексте программы сослаться на i-ый элемент ZСHtmlItem
//		   писателя H, то в случае когда данный элемент ранее не создавался 
//		   посредством оператора <<, данный элемент будет автоматически создан
//		   "писателем", так же как и все предыдущие элементы не созданные
//		   ранее. Все поля созданного таким образом элемента будут пустыми,
//		   например имя тега n будет пустой строкой, и как следствие в документе
//		   данные теги отображаться не будут.
//		   Пример 
//				ZСHtmlItem I;
//				I.n = "p";
//				I.txt = "какой-то там текст ...";
//				// Добавлен первый элемент
//				H << I;			
//				// Добавлен второй элемент
//				H << ZСHtmlItem("table",  0, "", nullptr);
//				// Добавляем 5-й элемент
//				// Одновременно задаём имя тега - заголовок
//				H(4).n = "h3";
//		   После выполнения последнего оператора кроме 5-го элемента
//		   будут созданы еще и 3-й и 4-й, то есть H(2) и H(3). Содержание
//		   данных элементов будет отсутствовать.
//		   !!!! Да конечно решение спорное ... но ... !!!!
//
//		6) Если вызвать оператор доступа () без аргумента то будет дан 
//		   доступ к последнему созданному элементу.
//		   Если же не одного элемента ещё на было создано то создаётся
//		   первый элемент (то есть с индексом ноль) и возвращается 
//		   ссылка на него
//		   Пример:
//				H().n = "h4"; - задаётся имя последнего добавленного тега.
//
//		7) В каждый тег (элемент ZСHtmlItem) может быть добавлен один или 
//		   более дочерних тегов.
//		   Синтпаксис аналогичен синтаксису добавления элемента в "писателя".
//		   Например:
//				ZСHtmlItem I;
//				I.n = "p";
//				I.txt = "какой-то там текст ...";
//				H(5) << I;			
//				H(5) << ZСHtmlItem("table",  0, "", nullptr);
//				H(5)(4).n = "h3";
//				H(5)(4).txt = "Заголовок";
//		   В данном примере у 6-го элемента документа H(5) будет создано
//		   5-ть дочерних (вложенных) элементов H(5)(0), H(5)(1), H(5)(2),
//		   H(5)(3), H(5)(4).
//		   В HTML документе в последствии будет сформирована конструкция
//				<некоторый родительский тег>
//					<p>
//						какой-то там текст ...
//					</p>
//					<table>
//						// Содержание таблицы
//					</table>
//					// теги H(5)(2) и H(5)(3) в документе не отобразятся
//					// так как они пустые.
//					<h3>
//						Заголовок
//					</h3>
//				</некоторый родительский тег>
//		   С учётом пункта 5 "in my look" было бы короче и читаькльнее писать 
//		   конструкции следующего вида:
//				H(5)(0).n   = "p";			
//				H(5)(0).txt = "какой-то там текст ...";
//				H(5)(1).n   = "table";			
//				H(5)(4).n   = "h3";
//				H(5)(4).txt = "Заголовок";
//		   Опять же решение спорное ...
//
//		8) Каждый элемент HtmlItem может содержать список атрибутов ZSHtmlAttr
//		   Доступ к атрибуту как сказано выше разрешён посредством [].
//		   Атрибут содержит два строковых поля:
//				- n, имя
//				- v, значение
//		   Синтаксис имени и значения соответствует синтаксису HTML или CSS.
//		   Например:
//				H(5)[0].n = "color";
//				H(5)[0].v = "#FF00FF";
//		   Аналогично вызову оператора () для несуществующего элемента, вызов
//		   оператора [] для несуществующего атрибута приводит к его созданию.
//		   При этом поля n и v атрибута будут пустыми строками.
//		   Для списка ат рибутов определён также оператор << как оператор
//		   добавления нового атрибута. Например:
//				H(5) << "color\n#FF00FF";	// no comments 
//		   Возможно добавление сразу нескольких атрибутов
//				H(5) << "color\n#FF00FF\nalign\nright";	
//		   В качестве разделителя может выступать как \n так и \t. Разделители
//		   окружать пробелами не возброняется.
//
//		9) Для поля txt элемента возможны инъекции HTML-кода для уточнения
//		   свойств отображения данного текста. Например
//				H(5).txt =
//		   "Расчет зон радиовидимости низкоорбитальных космических аппаратов/
//		   <b><i>(НКА)</i></b> космическими аппаратами изделия /
//		   <font color=\"FF0000\">14К047</font> <b><i>(СР)</i></b> проводится /
//		   на основании <span class="mytyle">прогнозов движения центра масс/
//		   НКА и СР</span>. ..."; 
//		   Синтаксис таких инъекций является синтаксисом HTML.
//
//		10)Документ полностью сформирован достаточно вызвать метод
//				H.Flash("Результаты прогноза параметров движения");
//		   В результатае на диске будет создан документ 
//				"Результаты прогноза параметров движения.html"
//		   а при необходимости и документ со стилями
//				"Результаты прогноза параметров движения.css"
//
//
//		Как-то так ... 
//
//		Use it as a sample for your applied program code.
//-----------------------------------------------------------------------------
#pragma once
#include <stdio.h>
#include <stdlib.h>
#include <io.h>
#include <tchar.h>
#include <string.h>
#include <string>
#include <vector>
#include <list>
#include <iterator>
#include <map>

#include <FlyHtmlWriterSource\\ZСHtmlCssStyles.h>
#include <FlyHtmlWriterSource\\ZСHtmlItem.h>

//-----------------------------------------------------------------------------
//
struct ZSMarkItem {
public: 
	ZSMarkItem(int _i1 = -1, int _i2 = -1, 
			   int _i3 = -1, int _i4 = -1, 
			   int _i5 = -1) {
		i[0] = _i1; i[1] = _i2; i[2] = _i3; i[3] = _i4; i[4] = _i5;
	}
	int& operator [] (long j) { return i[j]; }
	int i[5];
};

//-----------------------------------------------------------------------------
class FLY_HTML_WRITER_API ZCHtmlBuilder
{
public:
	ZСHtmlCssStyles	S;	 // Таблица стилей CSS

protected:				 // Корневой элемент. Все новые элемены добавляемые
	ZСHtmlItem		root;// оператором << являются дочерними для root  

private:
	string fileName;	 // Имя файла документа без расширения но с путём
	string shortFileName;// Имя файла без пути и без расширения
	string docHat;	     // Строка со всеми тегами заголовка до таблицы стилей
	string docEpigraf;	 // Форматированный эпиграф документа
	string docFinal;	 // Форматированный посскриптум документа

	// Карта меток ... используется для сохранения именованных меток
	// на элементы html-документа 
	// Отметив однажды некоторый элемент именем, в дальнейшем всегда можно 
	// получить его индекс.
	// Используется при многократном дополнении какого-либо элемента
	// в различных частях программного кода или при многократном вызове
	// некоторой функции документирования, последовательно 
	// формирующей данный элемент.
	// Создание и доступ к меткам возможет посредством методов 
	// CreateItemsMark и GetItemsMark
	map<string, ZSMarkItem> mapedPoint;

public:
	ZCHtmlBuilder(void);
	virtual ~ZCHtmlBuilder(void);

	//----------------------------------------------------------------------------
	// Доступ к эжлементам документа
	//----------------------------------------------------------------------------

	// Добавить новый элемент в документ
	// I должен содержать как тег, так и текст, а также массив 
	// вложенных элементов (тегов).
	// Если имя тега отсутствует то текст вставляется как неформатированный
	// текст и не обрамляется никаким тегом.
	ZCHtmlBuilder& operator << (ZСHtmlItem& I);
	// Доступ к одму из элементов документа по индексу
	ZСHtmlItem& operator() (long i = -1);
	// Колличество элементов в документе
	int CountItems() const;

	// Создание именнованной метки элемента, точнее индекса этого элемента
	int CreateItemsMark(char* key, ZSMarkItem& mi);
	// Удаление именнованной метки элемента
	int DeletItemsMark(char* key);
	// Получение индекса элемента по его метке
	ZSMarkItem GetItemsMark(char* key);

	// Признак использования стилей описанных в общем для всех документов
	// CSS-файле с именем 
	void UseDefaultStyles(bool useDefFile = true);

	// Создание таблицы стилей по умолчанию.
	// Если данный метод не вызывать то таблица стилей в 
	// создаваемом документе будет отсутствовать. Тогда либо совсем без
	// стлей, либо задавать их самостоятельно, 
	// либо воспользоваться файлом ".css"
	virtual void BuildStyles();

	// Начало создания нового документа
	virtual void Init(
		const char* docTitle=nullptr,	// Заголовок окна в браузере
		const char* docHeader=nullptr,	// Заголовок документа
		const int   headerLevel=4,		// Уровень заголовка (h1-0...h6-5)
		const char* docText=nullptr,	// Текст документа, заключается в тег <p>
		const char* fileName=nullptr);	// Имя файла без расширения

	//----------------------------------------------------------------------------
	// Создание Html-документа по сформированному описанию
	// Документ создаётся полностью до конца
	// Если при инициализации Init задано имя файла fileName, 
	// то при вызове метода Flash имя файла задавать не обязательно
	virtual int Flash(const char* fileName=nullptr);

	//----------------------------------------------------------------------------
	// Поэтапное документирование. Удобно и даже необходимо при создании 
	// достаточно больших документов в течении длительных рассчётов.
	// В такой ситуации контент выдаётся в документ частями по мере его 
	// формирования прикладной программой.
	//----------------------------------------------------------------------------

	// Начало поэтапного документирования.
	virtual void* BeginFlash(const char* fileName = nullptr);
	// Промежуточное документирование всех сформированных элементов.
	// Осуществляется дозапись уже созданного
	// документа html на который указывает file.
	virtual int MediateFlash(const void* file);
	// Завершение последовательного промежуточного (поэтапного) 
	// документирования. Осуществляется дозапись уже созданного
	// документа html на который указывает file. Записывается
	// постскриптум и закрываются теги <body> и <html>
	virtual int EndFlash(const void* file);

private:
	// Создание CSS-файла
	int FlashStyles(FILE* f);
	// Открытие и закрытие файла для записи с заданным именем и 
	// с заданным расширением
	FILE* OpenFile(const char* fileName, const char* ext = "html");
	void  CloseFile(FILE* of);
};

//-----------------------------------------------------------------------------